---
title: "Variance covariance model to  GxE analysis"
author: 
  - name: "Moshood Agba Bakare"
    affiliation: "JeanLuc's Lab Cornell University"
date: "`r Sys.Date()`"
header-includes:
  - \usepackage{amsmath}
output:
  bookdown::html_document2:
    fig_caption: true
    number_sections: true
    df_print: paged
    mathjax: "default"
    highlight: kate
    toc: true
    toc_depth: 3
    #css: "my_style.css"
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
# Configuring global parameters
knitr::opts_chunk$set(echo = TRUE, message = FALSE, error=FALSE, warning = FALSE,
                      fig.align = "center", fig.height = 6, fig.width = 6,
                      class.source = "lineAnchors")
```


```{r, include=FALSE, message=FALSE, error=FALSE, warning=FALSE}
#=======================================================================
# Packages
#=======================================================================
if (!require("pacman")) {
  install.packages("pacman")
}
# Include all packages here
pacman::p_load(
  plyr,
  ggplot2,
  ggrepel,
  gplots,
  factoextra,
  dplyr,
  tidyverse,
  tidyr,
  reshape,
  tibble,
  cluster,
  asreml,
  asremlPlus,
  AGHmatrix,
  superheat,
  ASRgenomics,
  RColorBrewer,
  kableExtra, 
  prettycode,
  formattable
)
prettycode::prettycode() 
```


# Read combined GxE data in csv format into R 
The combined GxE data is imported into R and transposed from wide to narrow format for easy visualization of key variables of interest.

```{r,importData}
# Import the combined raw data in wide format
phenoDat <- read.csv(file="data/combined_trial.csv", header=TRUE)

# Subset key variable and transpose the imported data in wide format to a narrow format
narrowPhenoDat <- phenoDat %>%
  dplyr::select(loc, year, env, trial, set, rep, gen,prop_hav, fyld, dyld, tyld, dm) %>%
  gather(key = trait, value = y, -c(loc, year, env, trial, set, rep, gen, prop_hav))

# write the narrow format combined GxE data file to a working directory data
write.csv(narrowPhenoDat,file="output/narrowPhenoDat.csv", row.names=FALSE)

# coerce variable to factors
narrowPhenoDat$trial <- as.factor(narrowPhenoDat$trial)
narrowPhenoDat$loc <- as.factor(narrowPhenoDat$loc)
narrowPhenoDat$year <- as.factor(narrowPhenoDat$year)
narrowPhenoDat$env <- as.factor(narrowPhenoDat$env)
narrowPhenoDat$trait <- as.factor(narrowPhenoDat$trait)

narrowPhenoDat$year <- factor(narrowPhenoDat$year, levels = c("2017","2018", "2019", "2020"), labels = c("2016-2017","2017-2018", "2018-2019", "2019-2020"))

narrowPhenoDat$trait <- factor(narrowPhenoDat$trait,
                           levels = c("fyld", "dm","dyld","tyld"))
                           
```


# Data visualization

This is a boxplot showing the distribution of key traits of interest across environments i.e. location and year combination

```{r,boxplot_env_trait}

boxplot_env_trait <- ggplot(data = narrowPhenoDat,
                             aes(x=loc,y=y, fill = "grey30", 
                                 alpha = 0.5)) +

  geom_boxplot(stat = "boxplot",  
                 outlier.colour = "black", 
                 outlier.alpha = 1.5, 
                 outlier.shape = 16, 
                 outlier.size = 1.5, 
                 na.rm=TRUE) +
  stat_summary(fun=mean, 
               colour="blue", 
               geom="point", na.rm = TRUE) + 
  
  labs(x= "Location", y= "Response values") + theme_bw() +
  theme(axis.title=element_text(colour="black",face="bold", size=12),
         axis.text = element_text(size=7),
        axis.text.x = element_text(angle = 90, size=11,hjust = 1),
        axis.text.y = element_text(size=11),
        legend.position="none",
        strip.text = element_text(size = 14, color = "black")) +
  
    facet_grid(trait~year, scales = "free")


# save the plot to a file
ggsave("output/boxplot_env_trait.jpeg",height=10, width=8, units="in", dpi=300)

print(boxplot_env_trait)
```


# A diagnostic plot I

This is a diagnostics plot of CV vs broad-sense heritability of fresh root yield (t/ha) of each trial. The input file to generate this plot is a summary statistics of raw data from using SAS application.

```{r, CV_vs_H2, results='hide'}
# read summary statistics output file
stats.output <- read.csv(file="output/raw_pheno_trial_summary.csv", header=T)

# filter the trait of interest from the summary output file
stats.output <- subset(stats.output, trait=="fyld") # subset for fresh root yield trait

cv_vs_H2 <- ggplot(data = stats.output,
       aes(x = H2,
           y = cv)) + 
  geom_point(color = ifelse(stats.output$cv > 40.5 | stats.output$H2 < 0.05, "#E41A1C", "#4DAF4A"),size = 1.7,
             alpha = 0.5) +
  scale_color_brewer(palette = "Set1") +
  geom_text_repel(aes(x = H2,
                      y = cv,
                      label = trial),
                  size = 2.5, segment.colour = NA) +
  labs(x = "Heritability", y = "CV (%)") +
  scale_x_continuous(breaks = seq(from = 0.0, to = 0.70, by = 0.1)) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(size = 7, hjust = 0.5),
        axis.text.y = element_text(size = 7, hjust = 0.5, angle = 90),
       axis.title.y = element_text(size = 10, face = "bold"),
       axis.title.x = element_text(size = 10, face = "bold"),
       legend.background = element_rect(fill = "NA", color = "black", size = 0.5),
       legend.text = element_text(size = 7),
       legend.title = element_text(size = 10, face = "bold"),
       legend.position = "right"
 )


# display the plot
print(cv_vs_H2)

# save the plot to a file
ggsave("output/cv_vs_H2.jpeg",height=4.2, width=6.5, units="in", dpi=300)
```


# A diagnostic plot II

This is a  diagnostics plot of experimental accuracy vs broad-sense heritability of fresh root yield (t/ha) of the trials. The input file to generate this plot is a summary statistics of raw data resulting from using SAS application.

```{r,Ac_vs_H2}

# filter the trait of interest from the summary output file
Ac_H2_output <- subset(stats.output, trait=="fyld", select= c("trial","trait","H2","Accr"))

Ac_vs_H2 <- ggplot(data = Ac_H2_output,
       aes(x = H2,
           y = Accr)) +
  geom_point(color = ifelse(Ac_H2_output$Accr < 0.40 | Ac_H2_output$H2 < 0.05, "red", "green"),size = 1.7,
             alpha = 0.5) +
  scale_color_brewer(palette = "Set1") +
  geom_text_repel(aes(x = H2,
                      y = Accr,
                      label = trial),
                  size = 2.5, segment.colour = NA) +
  labs(x = "Heritability",
       y = "Experimental accuracy") +
 theme_light() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(size = 7, hjust = 0.5),
        axis.text.y = element_text(size = 7, hjust = 0.5, angle = 90),
       axis.title.y = element_text(size = 10, face = "bold"),
       axis.title.x = element_text(size = 10, face = "bold"),
       legend.background = element_rect(fill = "NA", color = "black", size = 0.5),
       legend.text = element_text(size = 7),
       legend.title = element_text(size = 10, face = "bold"),
       legend.position = "right"
 )

# output the plot
print(Ac_vs_H2) 


# output the plot to a file
ggsave("output/Ac_vs_H2.jpeg",height=4.2, width=6.5, units="in", dpi=300)

```


# Connectivity matrix among the trials

This chunk produces a heatmap of connectivity matrix showing the number of clones common between any pair of trials. 

```{r, connecMat}

# a vector list of low quality trials to be excluded from further analysis
trialRemoved <- c("18UYT36setAKN", "17C1UYT34UM", "19UYT36setAZA", "19UYT36setAMK")
pheno <- phenoDat %>% select(loc, year, env, trial, set, rep, prop_hav, gen, fyld) %>%
dplyr::filter(!trial  %in% trialRemoved)

# coerce to variables to factor
pheno$loc <- as.factor(pheno$loc)
pheno$year <- as.factor(pheno$year)
pheno$env <- as.factor(pheno$env)
pheno$trial <- as.factor(pheno$trial)
pheno$rep  <- as.factor(pheno$rep)
pheno$gen <- as.factor(pheno$gen)
pheno$set <- as.factor(pheno$set)

pheno <- pheno[order(pheno$env, pheno$set, pheno$rep, pheno$gen),]


genCountPerTrial <- table(pheno$gen, pheno$trial) # count number of genotypes per trial
genCountPerTrial <- genCountPerTrial > 0
concmat <- t(genCountPerTrial) %*% genCountPerTrial


# Get lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}

# Get upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}


# Reorder the correlation matrix according to the correlation coefficient. 
# This is useful to identify the hidden pattern in the matrix. 
# hclust for hierarchical clustering order is used in the example below


reorder_cormat <- function(cormat){
  # Use correlation between variables as distance
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
}

# Reorder the correlation matrix
concmat <- reorder_cormat(concmat)
upper_tri <- get_upper_tri(concmat)


melted_cormat <- melt(upper_tri, na.rm = TRUE)

# Create a heatmapConnecMat
heatmapConnecMat <- ggplot(melted_cormat, aes(Var.2, Var.1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "red", high = "blue", mid = "green", 
                       midpoint = 45, limit = c(0,90), 
                       name="clone count") +
  theme_minimal() +
  
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 4, hjust = 1))+
  
  coord_fixed() + 
  theme(
    axis.text.x = element_text(size = 6, angle = 90, hjust = 1),
    axis.text.y = element_text(size = 6),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks = element_blank(),
    legend.justification = c(0.80, 0.50),
    legend.position = c(0.40, 0.94),
    legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 6, barheight = 1,
                               title.position = "top", title.hjust = 0.5))
  
# Print the heatmap
print(heatmapConnecMat)

# save the plot to a file
ggsave("output/heatmapConnecMat.jpeg",height=5, width=10, units="in", dpi=500)

write.csv(concmat,file="output/trial_conc_matrix.csv", row.names=FALSE)
```


# Read a pedigree data
The pedigree data is imported to calculate the pedigree-based relationship matrix to be used in further analysis

```{r, pedigree}
# read pedigre data
ped <- read.csv(file="data/pedigreData.csv",header = TRUE)

### Constructing the A matrix from pedigree
Amat <- AGHmatrix::Amatrix(data=ped)
dim(Amat) # 153 x 153


## matching Pedigree matrix (153 x 153) with the phenotype data file (96 genotypes) 
##############=================================================
checkMatchAmat<-match.kinship2pheno(K =Amat,pheno.data =pheno,indiv = "gen", clean = TRUE, ord = FALSE,mism = TRUE)
class(checkMatchAmat)
ls(checkMatchAmat)

clean_Amat<-(checkMatchAmat$Kclean)
dim(clean_Amat)#[1:96,1:96]

Ainv_full <- G.inverse(G=clean_Amat, sparseform = FALSE )$Ginv # A inverse in full form

Ainv_sparse <- full2sparse(Ainv_full, drop.zero = TRUE) # A inverse in sparse form

saveRDS(Ainv_sparse, file="output/PAinv.sparse.rds") # save pedigree-based kinship matrix
```



# Read a SNPS marker data

The SNPS marker data is imported to calculated a genomic-based kinship matrix among the evaluated cassava genotypes.

```{r, snpsMarker}
# read snps data as a matrix object
snps <- as.matrix(readRDS(file="data/snpsMarkerData.rds"))

snpsFilter <- qc.filtering(M=snps, base=FALSE, ref=NULL, maf=0.05, marker.callrate=0.2,ind.callrate=0.2, impute=FALSE, na.string='-9', plots=TRUE)

snpsFilter$M.clean[1:5, 1:5]
dim(snpsFilter$M.clean)

# plot of cleaned snps marker data
snpsFilter$plot.heteroz
snpsFilter$plot.maf
snpsFilter$plot.missing.ind
snpsFilter$plot.missing.SNP

# additive rel. matrix
GA <- G.matrix(M = snpsFilter$M.clean, method = "VanRaden", na.string = NA)$G

range(diag(GA))
range(GA[lower.tri(GA)])
mean(GA[lower.tri(GA)])

# diagnostic on kinship matrix
check_G <- kinship.diagnostics(K = GA)

# list flagged element of the diagonal
check_G$list.diagonal

# histogram of diagonal and off-diagonal element
check_G$plot.diag
check_G$plot.offdiag
```


# Tuning G and A matrices

This is to match individual in the pedigree-based relationship matrix with individual in the genomic-based relationship matrix and perform alignment.

```{r, tuningAlignment}
# Match individual in the A matrix with individual in the G matrix
G2A <- match.G2A(A = clean_Amat, G = GA, clean = TRUE, ord = TRUE, mism = TRUE,
RMdiff = TRUE)


# use Gclean and Aclean matrices to perform alignment
G_align <- G.tuneup(G = G2A$Gclean, A = G2A$Aclean, align = TRUE)$Gb

# perform diagnostics on align matrix
check_G_align <- kinship.diagnostics(K = G_align)

# histogram of diagonal and off-diagonal from alignment
check_G_align$plot.diag
check_G_align$plot.offdiag
```


# Generate hybrid (H) matrix

This is to generate an hybrid (H) matrix which combines both pedigree and genomic-based relationship matrices. The H matrix is required to fit the single step genomic best linear unbiased predictor ssGBLUP model.

```{r}
# obtain G inverse matrix from the alignment in full form for H matrix
GAinv.full <- G.inverse(G = G_align, sparseform = FALSE)$Ginv

# obtain H inverse matrix in sparse form from cleaned pedigree matrix 96 x96 
# and G inverse in full form. H inverse matrix is used in model fitting for computational efficiency.

Hinv <- H.inverse(A = clean_Amat, G = GAinv.full, lambda = 0.9, sparseform = TRUE)
saveRDS(Hinv, file="output/Hinv.sparse.rds") # save the matrix to a file

# obtain H matrix and check diagnostic. H must be in full form and not in inverse format
Hmat <- H.inverse(A = clean_Amat, G = GAinv.full, lambda = 0.9, sparseform = FALSE, inverse=FALSE)
#saveRDS(Hmat, file="output/Hmatrix.rds")
kinship.diagnostics(K = Hmat) # check H matrix
```


# Fit diagonal variance structure (DIAG) model

This model postulates assumption of independence of genetic effect among environments.

```{r, diagModel}
cat("\n Output from fitting Diagonal variance structure (DIAG)  model","\n")
DIAG <- asreml(fixed = fyld ~ env/set + prop_hav,
        random =~at(env):(set:rep) + diag(env):vm(gen,Hinv), # nested genetic  effect within envs
	      residual =~dsum(~units|env),
        na.action =na.method(y='include',x='include'),
        workspace = 250e6,maxit=50, data=pheno)

DIAG <- update.asreml(DIAG)
DIAG.fitstat <- infoCriteria(DIAG)
print(DIAG.fitstat)
DIAGvar <- summary(DIAG,vparameters=TRUE)$varcomp[,1:3]

ne <- nlevels(pheno$env) # number of environment

#  Compute variance covariance matrix
sigma2g <- round(diag(DIAGvar[grep("env.*vm", rownames(DIAGvar)),1]),3)
varCovMt <-round(matrix(sigma2g, ncol = ne, nrow = ne),2)

rownames(varCovMt) <- unique(levels(pheno$env))
colnames(varCovMt) <- unique(levels(pheno$env))
print(varCovMt)
write.csv(varCovMt, file = "output/DIAG_corrVarCov.csv")
```



# fit compound symmetry (CS) model
This model postulates homogeneity of genetic variance within environments and uniform covariance/correlation between any pair of environments

```{r, csModel}
cat("\n Output from fitting Compound Symmetry (CS)  model","\n")

CS <- asreml(fixed=fyld~env/set + prop_hav,
                random=~at(env):(set:rep) + vm(gen,Hinv) + 
               idv(env):vm(gen,Hinv),# additive var(g) and var(ge) 
                residual=~dsum(~units|env),
                na.action=na.method(y='include',x='include'),
                workspace=250e6,maxit=50, data=pheno)

CS <- update.asreml(CS)
CS.fitstat <- infoCriteria(CS)
print(CS.fitstat)
CSvar <- summary(CS,vparameters=TRUE)$varcomp[,1:3]
#print(CSvar)

#  variance matrix
sigma2g <- round(CSvar[grep("^vm", rownames(CSvar)),1],3) # additive genetic var across envs
cat("\n  genetic variance from  Compound Symmetry (CS)  model ",sigma2g,"\n")

sigma2ge <- CSvar[grep("env.*vm", rownames(CSvar)),1] #  genetic var x environments 
cat("\n  genotype x environment variance from  Compound Symmetry (CS)  model ",sigma2ge,"\n")

cat("\n Correlation variance covariance matrix  from  Compound Symmetry (CS)  model","\n")

varCovMt <-round(matrix(sigma2g, ncol = ne, nrow = ne) + diag(sigma2ge, nrow = ne),2)

rownames(varCovMt) <- unique(levels(pheno$env))
colnames(varCovMt) <- unique(levels(pheno$env))

corrMt <- round(cov2cor(varCovMt),2)
varCovMt[lower.tri(varCovMt)] <-  corrMt[lower.tri(corrMt)]

print(varCovMt)
write.csv(varCovMt, file = "output/CS_corrVarCov.csv")
```


# Fit compound symmetry heterogeneous (CSH) model

This model postulates a uniform correlation between any pair of environments but heterogeneous variance structure to genotype effects within the environment.

```{r, cshModel}
cat("\n Output from fitting Compound Symmetry heterogeneous (CSH)  model","\n")
CSH <- asreml(fixed=fyld~env/set + prop_hav,
                random=~at(env):(set:rep) + vm(gen,Hinv) + idh(env):vm(gen,Hinv),
                residual=~dsum(~units|env),
                na.action=na.method(y='include',x='include'),
                workspace=250e6,maxit=50, data=pheno)

CSH <- update.asreml(CSH)
CSH.fitstat <- infoCriteria(CSH)
print(CSH.fitstat)
CSHvar <- summary(CSH,vparameters=TRUE)$varcomp[,1:3]
#print(CSHvar)

# variance matrix
sigma2g <- round(CSHvar[grep("^vm", rownames(CSHvar)),1],3) # additive genetic var across envs

cat("\n Genetic variance from CSH  model ",sigma2g,"\n")

#  gen x environment variance
sigma2ge <- CSHvar[grep("env.*vm", rownames(CSHvar)),1] # additive genetic x environment variance

varCovMt <-round(matrix(sigma2g, ncol = ne, nrow = ne) + diag(sigma2ge, nrow = ne),2)

rownames(varCovMt) <- unique(levels(pheno$env))
colnames(varCovMt) <- unique(levels(pheno$env))

corrMt <- round(cov2cor(varCovMt),2)
varCovMt[lower.tri(varCovMt)] <-  corrMt[lower.tri(corrMt)]

print(varCovMt)

# output variance component estimate
write.csv(varCovMt, file ="output/CSH_corrVarCov.csv")
```


# Factor analytic model
This model is a lower approximation to unstructured variance-covariance structure model and it provides a parsimonious and informative model for describing the GEI effect and accurate prediction of genotype effect


## Factor analytic (FA1) model

This chunk made a function call fa_model to fit factor analytic structure model of order 1 (FA1)

```{r, FA1Model}
cat("\n Output from fitting Factor Analytic (FA1)  model","\n")

# invoke the function to fit factor analytic model
source("output/fa_model.R")

# Invoke a defined function to  fit FA1 model
FA1  <- fa_model(k = 1, kinv = Hinv, Gparam = DIAG$G.param, Rparam = DIAG$R.param)
FA1.fitstat <- FA1$fa.fitstat
print(FA1.fitstat)
summary(FA1$fa.fit,vparameters=TRUE)$varcomp[,1:3]


# extract out factor loadings and specific variance to compute genetic variance
# lambda is latent environmental loadings

lambda <- matrix(FA1$fa.vars[grep("fa.*fa1", rownames(FA1$fa.vars)),1],ncol=1)
fa1.loadings <- as.vector(lambda)
psi <- FA1$fa.vars[grep("var", rownames(FA1$fa.vars)),1]


# genetic variance  variance matrix
sigma2g <- lambda %*% t(lambda) +  diag(psi)

rownames(sigma2g) <- unique(levels(pheno$env))
colnames(sigma2g) <- unique(levels(pheno$env))
corrMt <- round(cov2cor(sigma2g),2)
sigma2g[lower.tri(sigma2g)] <-  corrMt[lower.tri(corrMt)]

write.csv(sigma2g, file = "FA1_corrVarCov.csv")
gen.var  <- as.vector(diag(sigma2g)) # genetic variance
fa1.pct <- fa1.loadings^2/gen.var*100

# Compute the percentage of genetic variance attributed to factor loadings
fa1.pct <- fa1.loadings^2/gen.var*100
FA1.totVar <- round(mean(fa1.pct),2)

# extract out error variances and compute heritability

error.var <-  FA1$error.vars[,2]
H2 <- gen.var/(gen.var + error.var) 

cat("\n Percentage of variance explained by FA1 model: ",FA1.totVar,"%","\n")


# Put together the loadings and other paraneters estimated from FA1 model error.var, H2,

cat("\n Factor loadings and genetic variance estimate from FA1 model","\n")
FA1_var <- cbind(fa1.loadings, psi, gen.var,error.var, H2, fa1.pct)
rownames(FA1_var) <- unique(levels(pheno$env))
FA1.var <- FA1_var %>% data.frame() %>%
mutate_if(is.numeric, round, digits = 2) 
FA1.var <- tibble::rownames_to_column(FA1.var, var = "env")
# print(FA1.var)
write.csv(FA1.var, file = "output/FA1_loadings.csv",row.names = FALSE)
```


# Factor analytic (FA2) model

This is output of fitting factor analytic structure model of order 2 (FA2)

```{r, FA2Model}

cat("\n Output from fitting Factor Analytic (FA2)  model","\n")

# invoke the function to fit factor analytic model
source("output/fa_model.R")

# Invoke a defined function to  fit FA2 model
FA2  <- fa_model(k = 2, kinv = Hinv, Gparam = FA1$fa.fit$G.param, Rparam = FA1$fa.fit$R.param)
FA2.fitstat <- FA2$fa.fitstat
print(FA2.fitstat)

summary(FA2$fa.fit,vparameters=TRUE)$varcomp[,1:3]

# Extract out parameter estimate from the fitted FA2 model

# variance matrix
lambda <- matrix(FA2$fa.vars[grep("fa.*fa", rownames(FA2$fa.vars)),1], ncol = 2) 
psi <- FA2$fa.vars[grep("var", rownames(FA2$fa.vars)),1]


##  Singular value decomposition of loadings from FA2 model to have  unique solution
svd.FA2 <- svd(lambda)

#Using the SVD solutions, we can rotate loading to principal component solution:
L.star = svd.FA2$u %*% diag(svd.FA2$d)* (-1)
rownames(L.star) <- unique(levels(pheno$env))
colnames(L.star) <- c("fa1.loadings", "fa2.loadings")
fa1 <- L.star[,"fa1.loadings"]
fa2 <- L.star[,"fa2.loadings"]


# Compute genetic correlation variance covariance  matrix
sigma2g <- L.star %*% t(L.star) + diag(psi)
corrMt <- cov2cor(sigma2g)
sigma2g[lower.tri(sigma2g)] <-  corrMt[lower.tri(corrMt)]
sigma2g <- round(sigma2g,2)

print(sigma2g)
write.csv(sigma2g, file = "output/FA2_corrVarCov.csv")

# Compute the percentage of genetic variance attributed to factor loadings
gen.var <- as.vector(diag(sigma2g))
fa1.pct <- fa1^2/gen.var*100
fa2.pct <- fa2^2/gen.var*100
totGenVar  <- fa1.pct + fa2.pct # total genetic variance captured in each environment
FA2.totVar  <- mean(totGenVar) # total genetic variance captured by FA4 model



# Percentage of variance explained by the latent regression
FA1.var.explained <- round(mean(fa1.pct),2)
FA2.var.explained <- round(mean(fa2.pct),2)

# extract out error variances and compute heritability
error.var <-  FA2$error.vars[,2]
H2 <- gen.var/(gen.var + error.var)

cat("\n Percentage of genetic variance explained by first factor in FA2 model: ",round(mean(fa1.pct),1),"\n")
cat("\n Percentage of genetic variance explained by second factor in FA2 model: ",round(mean(fa2.pct),1),"\n")
cat("\n Percentage of total genetic variance explained by  FA2 model: ",FA2.totVar,"\n")

# Put together the loadings and other parameters estimated from FA2 model

cat("\n Factor loadings and genetic variance estimate from FA2 model","\n")
FA2_var <- cbind(fa1, fa2, psi, gen.var, error.var, H2,  fa1.pct, fa2.pct, totGenVar)
rownames(FA2_var) <- unique(levels(pheno$env))
FA2.var <- FA2_var %>% data.frame() %>%
mutate_if(is.numeric, round, digits = 2) 

FA2.var <- tibble::rownames_to_column(FA2.var, var = "env")
print(FA2.var)

write.csv(FA2.var, file = "FA2_loadings.csv",row.names = FALSE)

# Extract the genetic variance from the FA2 model parameters
gen_var <- data.frame(env= rownames(FA2_var), gen.var = FA2_var[,"gen.var"])

# Extract the random effect prediction - the BLUP of genetic effect
gen_blup <- FA2$fa.blup

blup <-  merge(gen_blup, gen_var, by.x="env",by.y = "env")

blup <- blup %>%
        mutate(PEV = std.error^2, accuracy = sqrt(1 - PEV/gen.var), reliability = 1 - PEV/gen.var) %>%
        mutate_if(is.numeric, round, digits = 4) %>%
        arrange(env, std.error)
# print(blup)
write.csv(blup, file ="output/FA2_blups.csv",row.names=FALSE)
```


# Factor analytic (FA3) model

This is output of fitting factor analytic structure model of order 3 (FA3)

```{r, FA3Model}
cat("\n Output from fitting Factor Analytic (FA3)  model","\n")

# invoke the function to fit factor analytic model
source("output/fa_model.R")


# Invoke a defined function to  fit FA3 model

FA3  <- fa_model(k = 3, kinv = Hinv, Gparam = FA2$fa.fit$G.param, Rparam = FA2$fa.fit$R.param)
FA3.fitstat <- FA3$fa.fitstat
print(FA3.fitstat)

summary(FA3$fa.fit,vparameters=TRUE)$varcomp[,1:3]


# Extract out parameter estimate from the fitted FA3 model

# variance matrix
lambda <- matrix(FA3$fa.vars[grep("fa.*fa", rownames(FA3$fa.vars)),1], ncol = 3)
psi <- FA3$fa.vars[grep("var", rownames(FA3$fa.vars)),1]


##  Singular value decomposition of environment loadings from FA3 model to have  unique solution
svd.FA3 <- svd(lambda)

# Using the SVD solutions, we can rotate loading to principal component solution:
L.star = svd.FA3$u %*% diag(svd.FA3$d)* (-1)
rownames(L.star) <- unique(levels(pheno$env))
colnames(L.star) <- c("fa1.loadings", "fa2.loadings", "fa3.loadings")

fa1 <- L.star[,"fa1.loadings"]
fa2 <- L.star[,"fa2.loadings"]
fa3 <- L.star[,"fa3.loadings"]

# get the rotated environment or factor loading of FA3 model to compute
# the genotype overall performance and stability (RMSD)
FA3.fa1 <- fa1
FA3.fa2 <- fa2
FA3.fa3 <- fa3


# Compute genetic correlation variance covariance  matrix

cat("\n Below is the correlation variance covariance matrix from FA3 model","\n")

sigma2g <- L.star %*% t(L.star) + diag(psi)
corrMt <- cov2cor(sigma2g)
sigma2g[lower.tri(sigma2g)] <-  corrMt[lower.tri(corrMt)]
sigma2g <- round(sigma2g,2)
write.csv(sigma2g, file = "FA3_corrVarCov.csv")
write.csv(corrMt, file = "FA3_genetic_corr.csv")
sigma2g

# Compute the genetic variance and the percentage of genetic variance attributed to factor loadings
gen.var <- as.vector(diag(sigma2g))
fa1.pct <- fa1^2/gen.var*100
fa2.pct <- fa2^2/gen.var*100
fa3.pct <- fa3^2/gen.var*100
totGenVar  <- fa1.pct + fa2.pct + fa3.pct  # total genetic variance captured in each environment
FA3.totVar  <- mean(totGenVar) # total genetic variance captured by FA4 model



# extract out error variances and compute heritability
error.var <-  FA3$error.vars[,2]
H2 <- gen.var/(gen.var + error.var)

# Display total and percentage of total genetic variance captured  by each each loading factor
cat("\n Percentage of variance explained by first factor in FA3 model: ",mean(fa1.pct),"\n")
cat("\n Percentage of variance explained by second factor in FA3 model: ",mean(fa2.pct),"\n")
cat("\n Percentage of variance explained by third factor in FA3 model: ",mean(fa3.pct),"\n")
cat("\n Percentage of total genetic variance explained by  FA3 model: ",FA3.totVar,"\n")


# Put together the loadings and other parameters estimated from FA3 model

cat("\n Factor loadings and genetic variance estimate from FA3 model","\n")
FA3_var <- cbind(fa1, fa2, fa3, psi, gen.var, error.var, H2, fa1.pct, fa2.pct, fa3.pct, totGenVar)
rownames(FA3_var) <- unique(levels(pheno$env))
FA3.var <- FA3_var %>% data.frame() %>%
mutate_if(is.numeric, round, digits = 2) 
FA3.var <- tibble::rownames_to_column(FA3.var, var = "env")
#print(FA3.var)

write.csv(FA3.var, file ="output/FA3_loadings.csv",row.names = FALSE)


# Extract the genetic variance from the FA3 model parameters
gen_var <- data.frame(env = rownames(FA3_var), gen.var = FA3_var[,"gen.var"])

# Extract the random effect prediction - the BLUP of genetic effect
gen_blup <- FA3$fa.blup

# extract the global intercept and add to blup to get the predicted value

gen_blup$predicted <- gen_blup$blup + FA3$fa.intercept[1]
blup <-  merge(gen_blup, gen_var, by.x="env",by.y = "env")

FA3.blup <- blup %>%
        mutate(PEV = std.error^2, accuracy = sqrt(1 - PEV/gen.var), reliability = 1 - PEV/gen.var) %>%
        mutate_if(is.numeric, round, digits = 4) %>%
        arrange(env, std.error)

#print(FA3.blup)
# output genotypic blup from FA3 model
write.csv(FA3.blup, file = "output/FA3_blups.csv",row.names=FALSE)

```


# Factor analytic (FA4) model
This is output of fitting factor analytic structure model of order 4 (FA4)

```{r, FA4Model}

cat("\n Output from fitting Factor Analytic (FA4)  model","\n")

# invoke the function to fit factor analytic model
source("output/fa_model.R")


# Invoke a defined function to  fit FA4 model
FA4  <- fa_model(k = 4, kinv = Hinv, Gparam = FA3$fa.fit$G.param, Rparam = FA3$fa.fit$R.param)
FA4.fitstat <- FA4$fa.fitstat
print(FA4.fitstat)

summary(FA4$fa.fit,vparameters=TRUE)$varcomp[,1:3]

# Extract out parameter estimate from the fitted FA4 model

# variance matrix
lambda <- matrix(FA4$fa.vars[grep("fa.*fa", rownames(FA4$fa.vars)),1], ncol = 4)
psi <- FA4$fa.vars[grep("var", rownames(FA4$fa.vars)),1]


##  Singular value decomposition of loadings from FA3 model to have  unique solution
svd.FA4 <- svd(lambda)

# Using the SVD solutions, we can rotate loading to principal component solution:
L.star = svd.FA4$u %*% diag(svd.FA4$d)* (-1)
rownames(L.star) <- unique(levels(pheno$env))
colnames(L.star) <- c("fa1.loadings", "fa2.loadings", "fa3.loadings","fa4.loadings")

fa1 <- L.star[,"fa1.loadings"]
fa2 <- L.star[,"fa2.loadings"]
fa3 <- L.star[,"fa3.loadings"]
fa4 <- L.star[,"fa4.loadings"]


# Compute genetic correlation variance covariance  matrix

cat("\n Below is the correlation variance covariance matrix from FA4 model","\n")

sigma2g <- L.star %*% t(L.star) + diag(psi)
corrMt <- cov2cor(sigma2g)
sigma2g[lower.tri(sigma2g)] <-  corrMt[lower.tri(corrMt)]
sigma2g <- round(sigma2g,2)

print(sigma2g)
write.csv(sigma2g, file = "FA4_corrVarCov.csv")


# Compute the genetic variance and percentage of genetic variance attributed to factor loadings
gen.var <- as.vector(diag(sigma2g))
fa1.pct <- (fa1^2/gen.var)*100
fa2.pct <- (fa2^2/gen.var)*100
fa3.pct <- (fa3^2/gen.var)*100
fa4.pct <- (fa4^2/gen.var)*100
totGenVar  <- fa1.pct + fa2.pct + fa3.pct + fa4.pct # total genetic variance captured in each environment
FA4.totVar  <- mean(totGenVar) # total genetic variance captured by FA4 model

# extract out error variances and compute heritability
error.var <- FA4$error.vars[,2]

H2 <- gen.var/(gen.var + error.var)


cat("\n Percentage of variance explained by first factor in FA4 model: ",mean(fa1.pct),"\n")
cat("\n Percentage of variance explained by second factor in FA4 model: ",mean(fa2.pct),"\n")
cat("\n Percentage of variance explained by third factor in FA4 model: ",mean(fa3.pct),"\n")
cat("\n Percentage of variance explained by four factor in FA4 model: ",mean(fa4.pct),"\n")
cat("\n Percentage of total genetic variance explained by  FA4 model: ",FA4.totVar,"\n")


# Put together the loadings and other paraneters estimated from FA4 model

cat("\n Factor loadings and genetic variance estimate from FA4 model","\n")
FA4_var <- cbind(fa1, fa2, fa3, fa4, psi, gen.var,error.var, H2, fa1.pct, fa2.pct, fa3.pct, fa4.pct, totGenVar)
rownames(FA4_var) <- unique(levels(pheno$env))
FA4.var <- FA4_var %>% data.frame() %>%
mutate_if(is.numeric, round, digits = 2) 
FA4.var <- tibble::rownames_to_column(FA4.var, var = "env")
# print(FA4.var)

write.csv(FA4.var, file = "output/FA4_loadings.csv", row.names = FALSE)
```



# Likelihood Ration Test and Model selection based on fit statistics

```{r,modelFitstatistics}

cat("\n","Likelihood Ratio Test comparing FA2 vs FA3 model","\n")

prob.improv <- REMLRT(FA2$fa.fit, FA3$fa.fit)
print(prob.improv)


cat("\n","Likelihood Ratio Test comparing FA3 vs FA4 model","\n")
prob.improv <- REMLRT(FA3$fa.fit, FA4$fa.fit)
print(prob.improv)

# Fit statistics across fitted model
cat("\n","Model diagnostic statistics","\n")
Model <- c("DIAG", "CS","CSH","FA1","FA2","FA3","FA4")
var.pct <- c(NA, NA, NA, FA1.totVar, FA2.totVar, 
             FA3.totVar, FA4.totVar)
fitstat <- rbind(DIAG.fitstat, CS.fitstat, CSH.fitstat, FA1.fitstat, 
                 FA2.fitstat, FA3.fitstat, FA4.fitstat)
fitstat <- fitstat[,-1]
fitstat <- as.data.frame(fitstat)

fitstat <- fitstat %>% mutate(Model = Model,var_pct = var.pct ) %>%
                select(Model, varDF, NBound, loglik, AIC, BIC, var_pct)
print(fitstat)
write.csv(fitstat, file="output/modelFitstat.csv")
```


# get the genotypic score of all genotypes from optimal FA3 model
Having identified FA3 as optimal model based on above diagnostic statistics, its parameters are explored to provide further insights into better understanding of complex GxE structure.

```{r, genScores}
#get the fa1 scores for all genotypes

fa1.scores <- coef(FA3$fa.fit)$random[grep("Comp1", rownames(coef(FA3$fa.fit)$random)),]
names(fa1.scores) = sub("vm(gen, Hinv)_", "", names(fa1.scores), fixed = T)
names(fa1.scores) = sub(":fa(env, 3)_Comp1", "", names(fa1.scores), fixed = T)


#get the fa2 scores for all genotypes from optimal FA3 model

fa2.scores <- coef(FA3$fa.fit)$random[grep("Comp2", rownames(coef(FA3$fa.fit)$random)),]
names(fa2.scores) = sub("vm(gen, Hinv)_", "", names(fa2.scores), fixed = T)
names(fa2.scores) = sub(":fa(env, 3)_Comp2", "", names(fa2.scores), fixed = T)


#get the fa3 scores for all genotypes from optimal FA3 model

fa3.scores <- coef(FA3$fa.fit)$random[grep("Comp3", rownames(coef(FA3$fa.fit)$random)),]
names(fa3.scores) = sub("vm(gen, Hinv)_", "", names(fa3.scores), fixed = T)
names(fa3.scores) = sub(":fa(env, 3)_Comp3", "", names(fa3.scores), fixed = T)

#rotate the genotypic scores
#make a vector f that has the N  genotype scores for fa1 stacked on top of the N genotype scores for FA3 model
f = rbind(as.matrix(fa1.scores), as.matrix(fa2.scores), as.matrix(fa3.scores))
f.star = kronecker(t(svd.FA3$v), diag(length(fa1.scores))) %*% f * (-1)
rownames(f.star) <- rownames(f)

#print(f.star)

# The object FA3gen.scores has the rotated genotypic scores fa1, fa2 and fa3  combined in columns

FA3gen.scores = data.frame(cbind(f.star[1:length(fa1.scores),1], f.star[(length(fa1.scores)+1):(length(fa1.scores)*2),1],
f.star[(length(fa1.scores)*2 + 1):length(f.star),1]))

FA3gen.scores <- tibble::rownames_to_column(FA3gen.scores, var = "gen")
names(FA3gen.scores) = c("gen","fa1", "fa2", "fa3")

print(FA3gen.scores) # output genotypic scores from fa1, fa2 and fa3 loadings

write.csv(FA3gen.scores, file="FA3_genotypic_score.csv")


# compute overall genotype performance

mean.fa1 <- mean(FA3.fa1) # take the mean of first rotated factor loading
genOP <- data.frame(FA3gen.scores[,c("gen","fa1")], meanEnvfa1=mean.fa1,OP=FA3gen.scores[,"fa1"]*mean.fa1)


# compute RMSD - global stability parameters

FA3_load <- FA3_var[,c("fa2","fa3")]

gen.scores <- as.matrix(FA3gen.scores[,c("fa2","fa3")])
rownames(gen.scores) <- FA3gen.scores[,"gen"]

dev <- gen.scores[,"fa2"] %*% t(FA3_load[,"fa2"]) + gen.scores[,"fa3"] %*% t(FA3_load[,"fa3"])
rmsd <- data.frame(gen = rownames(gen.scores),  RMSD =sqrt(rowMeans(dev^2)))

# merge output of OP and RMSD together 
fast <- merge(genOP[,c("gen","OP")], rmsd,by="gen")
cat("\n","Overall performance and global stability measures based on FA3 model","\n")
print(fast)
write.csv(fast, file="FA3_genotype_OP_RMSD.csv")

cat("\n","Select top 5 genotypes based on overall performance","\n")

selTopOP <- fast %>%
  slice_max(n=5, OP)

print(selTopOP)
write.csv(selTopOP, file="FA3_selTop_overallPerformance.csv")


cat("\n","Select top 5 genotypes based on stability","\n")
selTopRMSD <- fast %>%
  slice_min(n=5, RMSD)

print(selTopRMSD)
write.csv(selTopRMSD, file="FA3_selTop_stability.csv")


# rank the genotypes based on OP and RMSD and sum the rank
fast$rank_OP <- rank(-fast$OP)
fast$rank_RMSD <- rank(fast$RMSD)
fast$sum_rank <- fast$rank_OP + fast$rank_RMSD
fast <- fast[order(fast$sum_rank),]

print(fast)
write.csv(fast, file="output/FA3_ranked_genotype_OP_and_RMSD.csv")

```


# genetic correlation heatmap
```{r, genCorrPlot}
gencorr <- read.csv("output/FA3_genetic_corr.csv", header = T,row.names = 1)

colnames(gencorr) <- rownames(gencorr)
# construct dissimilarity matrix from gen corr matrix
disMt <- 1- gencorr

agnes.fa3 <- agnes(x = disMt, diss = TRUE, method = "ward")
den.ord <- row.names(gencorr)[agnes.fa3$order]

cor.df <- gather(gencorr[den.ord, den.ord])

names(cor.df) <- c('Env1', "Cor")
cor.df$Env1 <- factor(cor.df$Env1, levels = rev(den.ord))
cor.df$Env2 <- factor(rep(den.ord, times = 27), levels = den.ord)

cor.df <- cor.df[order(cor.df$Env1, cor.df$Env2),]
cor.df <- cor.df[,c("Env1","Env2","Cor")]
cor.df$Cor[cor.df$Env1 == cor.df$Env2] <- NA

#hh <- rev(rainbow(256, start = 0, end = 2/3))
gencorr <- ggplot(data = cor.df, aes(y= Env1, x = Env2, fill=Cor)) + geom_tile() +
             labs(x="Environment", y= "Environment", fill="Genetic correlation") +
             scale_fill_gradient2(low = "red",
                                  mid = "white",
                                  high = "blue",
                                  na.value = "grey50",limits= c(-1.1,1.1)) +
  theme(axis.title=element_text(colour="black",face="bold", size=12),
        axis.text = element_text(size=7),
        axis.text.x = element_text(angle = 90, size=11,hjust = 1),
        axis.text.y = element_text(size=11),
        legend.position="right",
        strip.text = element_text(size = 14, color = "black"))


# output the plot to a file

ggsave("output/gencorr.jpeg",height=4.2, width=6.5, units="in", dpi=300)

print(gencorr) # output the plot

```


# Plot of overall performance vs RMSD

This chunk is to assess and identify the cassava genotypes with overall performance and global stability across the testing environments.


```{r,OP_vs_RMSD}

fa3_bestGen <- read.csv(file="output/FA3_genotype_OP_RMSD.csv", header=TRUE, row.names = 1)

FA3_op_vs_rmsd <- ggplot(fa3_bestGen, aes(x = RMSD, y = OP))  + 
  geom_point(color =ifelse(fa3_bestGen$OP > 0 & fa3_bestGen$RMSD < 2, "red", "blue"),size = 1.0, alpha = 0.5) + geom_hline(yintercept = 0, linetype="dashed") + geom_vline(xintercept = 2, linetype="dashed") +  theme_bw() +
   geom_text(data =fa3_bestGen,aes(label=gen), size=1.4,vjust =-1.05, hjust= 0.55,colour="black")+
  labs(x="Root of mean square deviation (t/ha)",y="Overall performance (t/ha)") +
  theme_bw() +
theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(size = 7, hjust = 0.5),
        axis.text.y = element_text(size = 7, hjust = 0.5, angle = 90),
       axis.title.y = element_text(size = 10, face = "bold"),
       axis.title.x = element_text(size = 10, face = "bold"),
       legend.background = element_rect(fill = "NA", color = "black", size = 0.5),
       legend.text = element_text(size = 7),
       legend.title = element_text(size = 10, face = "bold"),
       legend.position = "right"
 )


# output the plot to a file
ggsave("output/FA3_OP_vs_RMSD.jpeg",height=4.2, width=6.5, units="in", dpi=300)

print(FA3_op_vs_rmsd)
```



# Latent regression plot resulting from FA3 model

This section showed how genotype stability may be best viewed using latent regression plots which revealed genotypic responses to each rotated factor loading.

```{r, latentRegPlot}

# Invoke a defined funtion ggeModel from source script to fit GGE model
source("code/latentRegPlot.R")

# read saved latent regression effect output
cge_output <- read.csv(file="output/latentRegressionEffect.csv", header=T)


## OR Calculate common genetic effect across the three factor loadings as latent regression effect

cge_output <- data.frame()
loading <- FA3.var[,1:4]
for (i in 1:nrow(FA3gen.scores)){
    fa1_cge = loading[,2]*FA3gen.scores[i,2]
    fa2_cge = loading[,3]*FA3gen.scores[i,3]
    fa3_cge = loading[,4]*FA3gen.scores[i,4]
    tot_effect <- fa1_cge+fa2_cge+fa3_cge
    fa2_cum_effect <- fa2_cge+fa3_cge #Adjusted for factor 1
    gen <- FA3gen.scores[i,1]
    cge <- data.frame(loading,fa1_cge,fa2_cge,fa3_cge,tot_effect,fa2_cum_effect,gen)
    cge_output <- rbind(cge_output,cge)
}

write.csv(cge_output, file="output/latentRegressionEffect.csv",row.names = F)

# create a vector list of genotypes for latent regression plot
# First two (OP), the next two (stability), last two genotypes(High DM and game changer)

genList <- c("TMS13F1376P0018","IITA-TMS-IBA000070", 
             "TMS14F1306P0020","TMS13F1377P0018",
             "TMEB419", "TMS14F1036P0007")


# filter the above listed genotypes from the entire 96 genotypes

genplot <- cge_output %>%
  filter(gen %in% genList)


genplot$gen <- factor(genplot$gen, levels =
                         c("TMS13F1376P0018","IITA-TMS-IBA000070", 
             "TMS14F1306P0020","TMS13F1377P0018",
             "TMEB419", "TMS14F1036P0007"))

# call the defined function latentRegPlot to plot

P1 <- latentRegPlot(xval=genplot$fa1,yval=genplot$tot_effect,
                   xlab="Environment loadings for first rotated factor", ylab="CGE effects (t/ha)")
  
print(P1)
ggsave("output/latentRegPlotFactor1.jpeg",height=4.2, width=6.5, units="in", dpi=300) 
  
# plot the second rotated axis
P2 <- latentRegPlot(xval=genplot$fa2,yval=genplot$fa2_cum_effect,
                   xlab="Environment loading for second rotated factor", ylab="CGE effects adjusted for first factor (t/ha)")
   
print(P2)
ggsave("output/latentRegPlotFactor2.jpeg",height=4.2, width=6.5, units="in", dpi=300)   

# plot the third rotated factor
P3 <- latentRegPlot(xval=genplot$fa3,yval=genplot$fa3_cge,
                   xlab="Environment loadings for third rotated factor", ylab="CGE effects adjusted for first two factors (t/ha)")
   
print(P3)
ggsave("output/latentRegPlotFactor3.jpeg",height=4.2, width=6.5, units="in", dpi=300)

```


# Clustering of the testing environments
This is a dendogram showing the grouping of the testing environments based on
first three factor loadings resulting from optimal FA3 model using ward linkage method.

```{r, clusterEnvs}
# Coerce to matrix and convert to correlation matrix
env.loading <- read.csv(file="output/FA3_loadings.csv",header=T)

FA3.load <-  tibble::column_to_rownames(env.loading, "env")
FA3.load <- FA3.load[,c("fa1","fa2","fa3")]
dist.mat <- dist(FA3.load, method = "euclidean")


# Hierarchical clustering based on ward.D2 linkage method 

# fit the best linkage method
res.hc <- hclust(d=dist.mat, method="ward.D2")
 
# Cut tree into 4 groups
grp <- cutree(res.hc, k =2)
clusters <- dendextend::cutree(res.hc, k = 2)
plot(as.dendrogram(res.hc),ylab="Height",edgePar=list(col=4, lwd=3), cex=0.2, horiz=F) 


# Cut the tree

env_clusters <- fviz_dend(res.hc, cex = 0.4, k =3,
 color_labels_by_k = FALSE, rect = FALSE, lwd = 0.7, main="")

print(env_clusters)
ggsave("output/env_clusters.jpeg",height=8, width=10, units="in", dpi=300)
```


# Clustering based on location
This is a dendogram showing the grouping of the location from testing environment (location by year combination) based on average of the first three factor loadings resulting from optimal FA3 model using ward linkage method.


```{r, clusterLocs}
env.loading <- read.csv(file="output/FA3_loadings.csv", header=T,row.names = 1)

loc.loading <- env.loading %>%
  group_by(loc)%>%
  dplyr::summarize(fa1=mean(fa1),fa2=mean(fa2),fa3=mean(fa3))

loc.loading <- tibble::column_to_rownames(loc.loading, 'loc')

FA3.load <- loc.loading[,c("fa1","fa2","fa3")]
dist.mat <- dist(FA3.load, method = "euclidean")

# Clustering using ward.D2 linkage method
res.hc <- hclust(d=dist.mat, method="ward.D2")
plot(as.dendrogram(res.hc),ylab="Height",edgePar=list(col=4, lwd=3), cex=0.2, horiz=F) 


# Cut the tree
loc_clusters <- fviz_dend(res.hc, cex = 0.5, k =3,
 color_labels_by_k = FALSE, rect = FALSE, lwd = 0.8, main="")

# save the plot
ggsave("output/loc_clusters.jpeg",height=4.2, width=6.5, units="in", dpi=300)
print(loc_clusters)
```
